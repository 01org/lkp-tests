#!/bin/sh
# - events
# - revents
# - time
# - command

perf=/lkp/benchmarks/perf-stat/perf
[ -x "$perf" ] || exit

. $LKP_SRC/lib/env.sh
is_virt && exit 0

# perf may consume lots of fd
ulimit -n 102400

perf_reg_num()
{
	dmesg | grep -e 'Performance Events' -C 3 | sed -ne '1,$s/.*generic registers:\s*\([0-9]\+\)/\1/p'
}

avail_events=$(perf-events hardware cache)
check_event()
{
	echo $avail_events | grep -qFw -e "$1"
}

check_add_events()
{
	in_events=$(echo "$*" | tr '{},' '   ')
	for event in $in_events; do
		check_event $event || return 1
	done
	events="$events$*,"
}

if [ -n "$revents" ]; then
	events="$revents"
elif [ -n "$events" ]; then
	events=$(perf-events $events)
	[ -n "$events" ] || exit
else
	# Each event should be used only once, because we have no
	# event group support in stats/perf-stat yet
	reg_num=$(perf_reg_num)
	if [ "0$reg_num" -lt 4 ]; then
		check_add_events '{cycles,instructions,cache-references,cache-misses}'
		check_add_events '{branch-instructions,branch-misses}'
	else
		check_add_events '{cycles,instructions,cache-references,cache-misses,branch-instructions,branch-misses}'
	fi
	check_add_events '{dTLB-loads,dTLB-load-misses}'
	check_add_events '{dTLB-stores,dTLB-store-misses}'
	check_add_events '{iTLB-loads,iTLB-load-misses}'
	check_add_events '{node-loads,node-load-misses}'
	check_add_events '{node-stores,node-store-misses}'
	events="$events\
cpu-clock,task-clock,\
page-faults,context-switches,\
cpu-migrations,\
minor-faults,major-faults"
fi

opt_events="-e $(echo $events | sed 's/ / -e /g')"

[ -n "$command" ] || {
	. $LKP_SRC/lib/wait.sh
	setup_wait

	if [ -n "$time" ]; then
		command="$WAIT_POST_TEST_CMD --timeout $time"
	else
		command="$WAIT_POST_TEST_CMD"
	fi
}

# Disable NMI watchdog to free up one perf counter
test -e  /proc/sys/kernel/nmi_watchdog &&
echo 0 > /proc/sys/kernel/nmi_watchdog

exec $perf stat -a -I 1000 -x' ' $opt_events --log-fd 1 -- $command
