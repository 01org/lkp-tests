#!/bin/sh

. $LKP_SRC/lib/env.sh
. $LKP_SRC/lib/wait.sh
setup_wait

[ -n "$max_uptime" ] || max_uptime=$((5 * 3600))
max_uptime=${max_uptime%%.*}

should_touch_watchdog=
watchdog_initial_countdown=300
watchdog_reset_period=32

[ -x /usr/bin/schedtool ] && /usr/bin/schedtool -R $$	# SCHED_RR

wait_touch_watchdog()
{
	local elapsed=0

	while :
	do
		wait_timeout $watchdog_reset_period
		[ -f "$TMP/job-finished" ] && exit

		bmc-watchdog --reset

		elapsed=$(( elapsed + watchdog_reset_period ))
		[ $elapsed -gt $max_uptime ] && return
	done
}

start_bmc_watchdog()
{
	is_virt && return
	[ -x /usr/sbin/bmc-watchdog ] || return
	bmc-watchdog --stop 2>/dev/null || return

	[ -f /var/run/watchdog.pid ] && return
	[ -f /var/run/bmc-watchdog.pid ] && return
	(
	        set -o noclobber
		echo $$ > /var/lock/bmc-watchdog
	) 2>/dev/null || return

	bmc-watchdog -d -u 4 -p 0 -a 1 -F -P -L -S -O -i $watchdog_initial_countdown -e $watchdog_reset_period && {
		sleep 10
		local pid=$(pidof bmc-watchdog)
		[ -n "$pid" ] &&
		bmc-watchdog --get | grep -q 'Timer:.*Running' && {
			echo $pid > /var/run/bmc-watchdog.pid
			return
		}
	}

	bmc-watchdog --set --start-after-set -i $watchdog_initial_countdown || {
		bmc-watchdog --stop
		return
	}

	should_touch_watchdog=1
}
start_bmc_watchdog

if [ -n "$should_touch_watchdog" ]; then
	wait_touch_watchdog
else
	wait_post_test --timeout $max_uptime && exit 0
fi

touch $TMP/soft_timeout
touch $RESULT_ROOT/soft_timeout

# try to unblock the main shell, which will copy files to
# $RESULT_ROOT, which helps debug the hang reason
kill $(cat $TMP/pid-* /dev/null) 2>/dev/null
sleep 3
kill -9 $(cat $TMP/pid-* /dev/null) 2>/dev/null

# reboot it the hard way, if the main shell failed to reboot
sleep 3m && {
	echo w > /proc/sysrq-trigger
	echo s > /proc/sysrq-trigger
	sleep 10
	echo b > /proc/sysrq-trigger
}
