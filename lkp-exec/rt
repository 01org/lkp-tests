#!/bin/bash

shopt -s nullglob

script_name=$(basename $0)
usage()
{
	cat <<-EOF
echo "Usage: lkp $script_name [-d N[dwm]] [-f filename] patterns..."
echo "For example:"
echo "lkp $script_name -d 3d  lkp-ws02  xfstests /0/"
EOF

	exit 1
}

[[ $# = 0 ]] && usage

while getopts "f:d:" opt
do
	case $opt in
		f ) opt_file="$OPTARG"; ;;
		d ) opt_date="$OPTARG"; ;;
		? ) usage >&2; ;;
	esac
done

shift $(($OPTIND-1))

[[ $opt_date =~ [0-9]+d$ ]] && opt_date=${opt_date%d}
[[ $opt_date =~ [0-9]+w$ ]] && opt_date=$((${opt_date%w} * 7))
[[ $opt_date =~ [0-9]+m$ ]] && opt_date=$((${opt_date%m} * 30))


if [[ $opt_date ]]; then
	files=()
	for d in 0 $(seq $opt_date)
	do
		day=$(date +%F -d "$d days ago")
		files+=(/lkp/paths/$day-*)
	done
elif [[ $script_name =~ ^_ ]]; then
	files=(/lkp/paths/????-??-??-* /lkp/paths/.????-??-??-*)
else
	files=(/lkp/paths/????-??-??-*)
fi

[[ $files ]] || exit 0

export GIT_WORK_TREE=${GIT_WORK_TREE:-${LKP_GIT_WORK_TREE:-/c/repo/linux}}
export GIT_DIR=${GIT_DIR:-$GIT_WORK_TREE/.git}

flag_pattern=0
for pattern
do
	# expand v3.12 etc. to commit SHA1
	[[ "$pattern" =~ (v[0-9].[0-9]+[_-rc0-9]*) ]] &&
	{
		git_tag=$BASH_REMATCH
		git_tag="${git_tag%/}"

		commit=$(git rev-list -n1 "$git_tag" 2>/dev/null) &&
		[[ $commit ]] && pattern="${pattern/$git_tag/$commit}"
	}

	if [[ "$flag_pattern" = "0" ]]; then
		cmd="grep -h -E $pattern "${files[@]}""
		flag_pattern=1
	else
		cmd="$cmd | grep -E $pattern"
	fi
done

temp_file_unsort=$(mktemp)
eval "$cmd" > $temp_file_unsort

[[ -s "$temp_file_unsort" ]] ||
{
	rm -rf $temp_file_unsort
	exit 1
}

sed -i -e 's#/$##' $temp_file_unsort
temp_file_sort=$(mktemp)

case $script_name in
rt|ls|ll)
	sort $temp_file_unsort > $temp_file_sort
	;;
_rt)
	awk -F'/' '{OFS="/"; NF=NF-1; print}' $temp_file_unsort | sort -u > $temp_file_sort
	;;
__rt)
	awk -F'/' '{OFS="/"; NF=NF-2; print}' $temp_file_unsort | sort -u > $temp_file_sort
	;;
esac

show_one_path()
{
	case $script_name in
	ls)
		echo "$1"
		ls "$1"
		echo
		;;
	ll)
		echo "$1"
		ls -l "$1"
		echo
		;;
	*)
		echo "$1"
		;;
	esac
}

while read path
do
	if [[ ! $opt_file ]]; then
		show_one_path "$path"
	else
		file_path=$(find $path -name $opt_file)
		[[ $file_path ]] && show_one_path "$file_path"
	fi
done < $temp_file_sort


rm -rf $temp_file_unsort  $temp_file_sort
