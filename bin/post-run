#!/bin/bash

shopt -s nullglob
umask 002

wait_for_monitors()
{
	local pidfile=$TMP/.pid-wait-monitors
	[[ -s $pidfile ]] || return 0

	for i in 1 2 3 4 5
	do
		sleep $i
		pgrep --pidfile $pidfile >/dev/null && continue
		return 0
	done

	echo "some monitors do not quit in time" >&2
	ps faux >&2
}

$LKP_SRC/monitors/event/wakeup post-test
wait_for_monitors

kill $(cat $TMP/pid-* /dev/null) 2>/dev/null

[[ -f $TMP/boottime ]] &&
cp $TMP/boottime	$RESULT_ROOT/

cp $TMP/time		$RESULT_ROOT/
[[ -s $TMP/time ]] || ps faux --cols 1000 > $RESULT_ROOT/time-debug

cp $TMP/env.yaml 	$RESULT_ROOT/

if [[ -f $RESULT_ROOT/run_log ]]; then
	echo "$RESULT_ROOT/run_log already exists, check race conditions" >> $TMP/err_log
	cp $TMP/run_log $RESULT_ROOT/run_log.1
elif [[ -f $TMP/run_log ]]; then	# run-local don't have run_log
	cp $TMP/run_log $RESULT_ROOT/
fi

PERF_EVENT_DATA=$TMP/perf.data
[[ -s $PERF_EVENT_DATA ]] && {
	perf report --header -U -g fractal,5 -i $PERF_EVENT_DATA 2>/dev/null | gzip > $RESULT_ROOT/perf-profile.gz && {
		rm -f $PERF_EVENT_DATA
	}
}

wait_for_pipe()
{
	local i
	local result

	for i in $(seq 5)
	do
		sleep $i
		pgrep --pidfile $TMP/.pid-pipes '(tee|cat|gzip)-.*' >/dev/null && continue

		for result in "${tmp_results[@]}"
		do
			[[ $result =~ '.gz' ]] || continue
			[[ -s $result ]] && continue

			echo "wait_for_pipe $i: empty $result" >&2
			continue 2
		done

		return 0
	done

	echo "wait_for_pipe timeout $i" >&2
	ps faux >&2
	ls -l $TMP_RESULT_ROOT >&2
	return 1
}

[[ $TMP_RESULT_ROOT ]] &&
[[ $TMP_RESULT_ROOT != $RESULT_ROOT ]] && {
	tmp_results=($TMP_RESULT_ROOT/*)
	[[ $tmp_results ]] && {
		# give chance to monitor fifo writer to sync data back to file
		wait_for_pipe
		chown lkp.lkp "${tmp_results[@]}"
		mv --no-clobber "${tmp_results[@]}" $RESULT_ROOT/
	}
}

[[ -s $TMP/err_log ]] &&
cp $TMP/err_log		$RESULT_ROOT/
