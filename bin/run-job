#!/usr/bin/ruby

# The job file is essentially grouped lists of commands to be executed with
# optional environment parameters.
#
# The commands are executed in order, thanks to ruby 1.9's ordered hash
# feature:
#   "the order that elements are yielded by each, each_key, each_value...
#   is defined to be the temporal order of insertion into the hash."

TMP = ENV['TMP'] || '/tmp'
LKP_SRC = ENV["LKP_SRC"] || File.dirname(File.dirname File.realpath $PROGRAM_NAME)

require 'yaml'
require 'pp'
require "#{LKP_SRC}/lib/job.rb"
require 'optparse'
require 'ostruct'

opts = OptionParser.new do |opts|
        opts.banner = "Usage: #{$PROGRAM_NAME} [options] job.yaml"

        opts.separator ''
        opts.separator 'options:'

        opts.on('--pid-file FILE', 'Save PID to FILE') do |file|
                File.open(file, 'w') { |f| f.write "#{$$}\n" }
        end

        opts.on('-s', '--shell', 'Create shell run script') do
		$opt_shell = true
		$shell_run = "#{TMP}/run-job.sh"
        end

        opts.on_tail('-h', '--help', 'Show this message') do
                puts opts
                exit
        end

end

if ARGV == []
        argv = ['-h']
else
        argv = ARGV
end
opts.parse!(argv)

$testcase = YAML.load_file(ARGV[0])
$top_env = expand_toplevel_vars Hash.new, $testcase

$child_pids = []

def shell_run_head
	File.open($shell_run, mode='w') { |file|
		file.puts "#!/bin/bash\n\n"
	}
end

def shell_export_env
	File.open($shell_run, mode='a') { |file|
		$top_env.each { |k, v|
			file.puts "export #{k}=\"#{v}\""
		}
		file.puts "\n\n"
	}
end

def shell_read_env_vars
	File.open($shell_run, mode='a') { |file|
		file.puts "\nread_env_vars()\n{"
		file.puts "\teval $(sed -e '/^ *$/d;/^#/d;s/: */=\"/g;s/$/\"/g;s/ *=/=/g' #{TMP}/env.yaml)"
		file.puts '}'
		file.puts "read_env_vars\n\n"
	}
end

def shell_run_pre_test(program)
	return if $pre_test_executed
	return unless $programs[program].index("#{LKP_SRC}/tests/") == 0
	$pre_test_executed = true
	shell_read_env_vars
	File.open($shell_run, mode='a') { |file|
		file.puts "#{LKP_SRC}/monitors/event/wakeup pre-test"
		file.puts "sleep 1"
		file.puts "date '+%s' > #{TMP}/start_time\n\n"
	}
end

def add_one_env(program_env, k, v)
	if v.class == Array and v[0].class != Array and v[0].class != Hash
		v = v.join ' '
	end
	if v.class != Hash and v.class != Array
		program_env[k] = expand_shell_var $top_env, v
		return true
	end
	return false
end

def program_env(program, env)
	program_env = {}

	env = strip_trivial_array(env)

	# expand predefined parameter set name
	if env.class != Hash and env.class != Array
		param_yaml = LKP_SRC + '/params/' + program + '.yaml'
		if File.exists?(param_yaml)
			params = YAML.load_file(param_yaml)
			env = params[env] if params[env]
		end
	end

	args = []
	if env.class == String
		return if env == 'disable'
		args = env.split if env != ''
	elsif env.class == Fixnum or env.class == Float
		args = env.to_s
	else
		for_each(env) { |k, v|
			add_one_env program_env, k, v and next
			for_each(v) { |kk, vv|
				add_one_env program_env, kk, vv
			}
		}
	end

	return program_env, args
end

def create_cmd(program, args)
	wrapper = File.dirname($programs[program]) + '/wrapper'
	if File.executable?(wrapper)
		cmd = [ wrapper, program, *args ]
	else
		cmd = [ $programs[program], *args ]
	end

	if $programs[program] =~ %r{/tests/}
		cmd = [ "/usr/bin/time", "-v", "-o", "#{TMP}/time", *cmd ]
	end

	return cmd
end

def shell_run_program(program, env)
	program_env, args = program_env(program, env)

	shell_run_pre_test(program)

	cmd = create_cmd(program, args)
	File.open($shell_run, mode='a') { |file|
		program_env.each { |k, v|
			file.print "\t" if $shell_run_program_indent
			file.puts "#{k}=#{v} \\"
		}
		file.print "\t" if $shell_run_program_indent
		file.puts cmd.join' '
	}
end

def shell_run_child(key, val)
	File.open($shell_run, mode='a') { |file|
		file.puts "#{key}()\n{"
	}
	$shell_run_program_indent = true
	for_each_program(val) { |k, v|
		shell_run_program(k, v)
	}
	$shell_run_program_indent = false
	File.open($shell_run, mode='a') { |file|
		file.puts "}\n\n"
		file.puts "#{key}&\n\n"
	}
end

def shell_wait_child()
	File.open($shell_run, mode='a') { |file|
		file.puts "\nwait"
	}
end

def run_child(key, val)
	val['testcase']  = $testcase['testcase']

	temp_yaml = "#{TMP}/lkp-run-job--#{key}--#{$$}.yaml"
	File.open(temp_yaml, mode='w') { |file|
		file.write(YAML.dump(val))
	}
	child_job_pwd = ENV['job_pwd']
	child_job_pwd += '/' unless child_job_pwd[-1] == '/'
	child_job_pwd += key
	$child_pids << Process.spawn($top_env.merge({'job_pwd' => child_job_pwd}),
				     "#{LKP_SRC}/bin/run-job #{temp_yaml}")
end


shell_run_head if $opt_shell

case $PROGRAM_NAME
when /run-job/
	$pre_test_executed = false
	create_programs_hash "{setup,monitors,tests}/**/*"
	ENV['job_pwd'] ||= '/'

	$testcase.delete_if { |key, val|
		next if $programs.include? key
		next if val.class != Hash

		if $opt_shell
			shell_run_child(key, val)
		else
			run_child(key, val)
		end

		# remove key and val to avoid re-run them in the end
		true
	}
when /job-env/
	create_programs_hash "{setup,monitors,tests}/**/*"
when /extract-stats/
	ARGV[1..-1].each { |f| $testcase.merge!(YAML.load_file(f)) }
	if $testcase['job_state'] == 'kernel_oops'
		create_programs_hash "stats/dmesg"
	elsif $testcase['job_state'] =~ /booting|running|soft_timeout|failed|error_mount|error_umount/
		create_programs_hash "stats/{dmesg,last_state}"
	else
		create_programs_hash "stats/**/*"
	end
else
	STDERR.puts "Unknown program name."
	exit 1
end

def run_pre_test(program)
	return unless $pre_test_executed == false
	return unless $programs[program].index("#{LKP_SRC}/tests/") == 0
	$pre_test_executed = true

	puts "run: pre-test"
	return if ENV["LKP_DRYRUN"]

	system "#{LKP_SRC}/monitors/event/wakeup", 'pre-test'
	sleep 1
	%x[ date '+%s' > #{TMP}/start_time ]
end

def run_program(program, env)
	program_env, args = program_env(program, env)

	if $PROGRAM_NAME =~ /job-env/
		puts program + ': 1'
		program_env.each { |key, val| puts "#{program}.#{key}: #{val}" }
		return
	end

	run_pre_test program

	cmd = create_cmd(program, args)

	puts "run: " + cmd.join(" ") + "\t" + program_env.to_s
	return if ENV["LKP_DRYRUN"]

	program_env['all_program_env'] = YAML.dump(program_env)
	ret = system $top_env.merge(program_env), *cmd
	case ret
	when false
		STDERR.puts program + ' ' + $?.to_s
		exit 1
	when nil
		STDERR.puts 'Cannot run ' + program
		exit 1
	end
end

def update_global_env
	return unless File.exists? "#{TMP}/env.yaml"
	env = YAML.load_file "#{TMP}/env.yaml"
	env.each { |k, v|
		env[k] = expand_shell_var $top_env, v
	}
	$top_env.update(env)
end

if $opt_shell
	update_global_env
	shell_export_env
	for_each_program($testcase) { |k, v|
		shell_run_program k, v
	}

	shell_wait_child
	exit
end

for_each_program($testcase) { |k, v|
	update_global_env
	run_program k, v
}

$child_pids.each { |pid|
	Process.waitpid(pid, Process::WNOHANG)
}

if $PROGRAM_NAME =~ /job-env/
	$top_env.each { |key, val| puts "#{key}: #{val}" }
end
