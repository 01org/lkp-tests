#!/usr/bin/ruby

Signal.trap("INT") { exit! }

LKP_SRC = ENV["LKP_SRC"] || File.dirname(File.dirname File.realpath $PROGRAM_NAME)

require "#{LKP_SRC}/lib/git.rb"
require "#{LKP_SRC}/lib/yaml.rb"
require "#{LKP_SRC}/lib/plot.rb"
require "#{LKP_SRC}/lib/stats.rb"
require "#{LKP_SRC}/lib/result.rb"
require 'optparse'
require 'ostruct'
require 'yaml'
require 'pp'
require 'gnuplot'
require 'set'

ABS_WIDTH = 10
REL_WIDTH = 10
ERR_WIDTH = 5

PERF_INDEX_KENREL = 'v3.14'
PERF_INDEX_KCONFIG = 'x86_64-rhel'

$opt_dimension = 'commit'
$opt_field = 'vmstat.cpu.sy'
$opt_grep  = Array.new
$opt_vgrep = Array.new
$options = {}

$perf_indices = {}
$base_gm = {}
$head_gm = {}
$nr_gm = {}

opts = OptionParser.new do |opts|
        opts.banner = 'Usage: compare [options] RESULT_ROOT...'

        opts.separator ''
        opts.separator 'options:'

        opts.on('-d DIMENSION', '--dimension DIMENSION', 'DIMENSION to compare: commit, kconfig, fs, etc.') do |dimension|
		$opt_dimension = dimension
        end

        opts.on('-f FIELD', '--field FIELD', 'FIELD to evaluate: vmstat.cpu.sy, iostat.sda.util, etc.') do |field|
		$opt_field = field
        end

        opts.on('-g PATTERN', '--grep PATTERN', 'only compare result roots that match PATTERN') do |pattern|
                $opt_grep.push Regexp.new(expand_possible_commit(pattern))
        end

        opts.on('-G PATTERN', '--invert-grep PATTERN', 'dont compare result roots that match PATTERN') do |pattern|
                $opt_vgrep.push Regexp.new(expand_possible_commit(pattern))
        end

        opts.on('-p', '--plot', 'plot bar graph') do
                $opt_plot = true
        end

        opts.on('-a', '--all', 'compare all') do
                $opt_all = true
        end

        opts.on('-t', '--group-by-test', 'test-grouped output format') do
                $group_by_test = true
        end

        opts.on('-i', '--index', 'performance/power index') do
		$opt_index	= true
		$size_index	= load_yaml LKP_SRC + '/etc/index-size.yaml'
		$perf_index	= load_yaml LKP_SRC + '/etc/index-perf.yaml'
		$power_index	= load_yaml LKP_SRC + '/etc/index-power.yaml'
		$latency_index	= load_yaml LKP_SRC + '/etc/index-latency.yaml'
		$all_index	= $perf_index.merge($power_index).merge($latency_index).merge($size_index)
        end

	opts.on("-D N", "--distance N", "threshold of changes") { |n|
		$options['distance'] = n.to_i
	}

	opts.on("-P", "--perf", "show performance changes only") {
		$options['perf'] = true
	}

	opts.on("-r N", "--resize N", "resize first matrix") { |n|
		$options['resize'] = n.to_i
	}

	opts.on("-v N", "--variance N", "show variance changes larger than N times") { |n|
		$options['variance'] = n.to_i
	}

	opts.on("--no-hide-noises", "do not hide noisy results") {
		$opt_no_hide_noises = true
	}

        opts.on_tail('-h', '--help', 'Show this message') do
                puts opts
                exit
        end

end

if ARGV == []
	argv = ['-h']
else
	argv = ARGV
end
opts.parse!(argv)

$dim_not_a_param = $opt_dimension =~ /^(testbox|kconfig|commit|run)$/

$changed_stats 	    = Hash.new { |hash, key| hash[key] = {} }
$stat_records 	    = Hash.new { |hash, key| hash[key] = [] }
$_result_root_tuple = Hash.new { |hash, key| hash[key] = [] }
$_result_root_saved = Set.new

$dims = Hash.new
$cases = Hash.new
$tests = Hash.new
$sum = Hash.new { |hash, key| hash[key] = 0 }
$stddev = Hash.new { |hash, key| hash[key] = 0 }

def plot_bar(dims, cases)
	return unless cases.empty?
	x = cases.keys
	Gnuplot.open do |gp|
		Gnuplot::Plot.new(gp) do |plot|
			plot.style "data histograms"
			plot.xtics "nomirror rotate by -45"
			plot.terminal "dumb nofeed"
			dims.each { |dim, name|
				y = []
				cases.each { |key, value|
					if value[dim]
						y.push value[dim]
					else
						y.push 0
					end
				}
				plot.data << Gnuplot::DataSet.new([x, y]) do |ds|
					ds.using = "2:xtic(1)"
					ds.title = name
				end
			}
		end
	end
end

def dim_name(dim)
	case $opt_dimension
	when 'commit'
		tag = commit_tag(dim)
		return tag if not tag.empty?
		return dim[0..(REL_WIDTH + ABS_WIDTH + ERR_WIDTH)]
	else
		return dim
	end
end

def get_json_field(file, key)
	matrix = load_json file
	matrix[key]
end

def add_stats(path)
	$opt_grep.each  { |re| return false if path !~ re }
	$opt_vgrep.each { |re| return false if path =~ re }

	if File.basename(path) =~ /^[0-9]{1,3}$/
		stats_json = path + '/stats.json'
	else
		stats_json = path + '/matrix.json'
	end
	unless File.exists? stats_json
		# No need for a warning here.
		# STDERR.puts stats_json + ' does not exist'
		return
	end
	field_value = get_json_field(stats_json, $opt_field)
	if field_value == nil or field_value == ''
		# STDERR.puts "#{stats_json}: no such field: #{$opt_field}"
		field_value = 0
	end

	result_path = Result_path.new
	result_path.parse_result_root(File.realpath(path))

	if $dim_not_a_param
		dim = result_path[$opt_dimension]
	else
		$params ||= YAML.load_file result_path.params_file
		return unless $params.has_key? $opt_dimension
		path_params = result_path['path_params'].partition Regexp.new '\b(' + $params[$opt_dimension].join('|') + ')\b'
		dim = path_params[1]
		return unless dim
	end

	if not $dims.has_key?(dim)
		$dims[dim] = dim_name(dim)
		$first_dim ||= dim
	end
	if $dim_not_a_param
		result_path[$opt_dimension] = $first_dim
	else
		result_path['path_params'] = path_params[0] + $first_dim + path_params[2]
	end
	_rt = result_path._result_root
	if !$cases.has_key?(_rt)
		$cases[_rt] = { dim => field_value }
	else
		$cases[_rt][dim] = field_value
	end
end

def add_result_root(result_root)
	$opt_grep.each  { |re| return if result_root !~ re }
	$opt_vgrep.each { |re| return if result_root =~ re }

	_result_root = File.dirname result_root
	return unless $_result_root_saved.add? _result_root

	$longest_dims.each { |dim|
		if _result_root.index(dim)
			key = _result_root.sub(dim, '')
			$_result_root_tuple[key] << _result_root
			return
		end
	}
end

def setup_test_group(result_root)
	result_path = Result_path.new
	result_path.parse_result_root result_root
	test = result_path.test_desc $opt_dimension
	if not $tests.has_key?(test)
		$tests[test] = test
	end
end

def setup_result_root_hash()
	ENV['LC_ALL'] = 'C'
	$opt_dims.each do |dim|
		`grep -h -r -F -e #{dim} #{RESULT_PATHS}`.each_line do |result_root|
			add_result_root result_root
			setup_test_group result_root
		end
	end
	$_result_root_tuple.delete_if { |k, v| v.size <= 1 }
end

def get_valid_average(matrix, key)
	samples = matrix[key]
	return nil unless samples
	return nil if samples.include? 0
	return nil if samples.size < matrix_cols(matrix)
	avg = matrix[key].average
	return nil if not $opt_no_hide_noises and matrix[key].standard_deviation > avg / 2
	avg
end

def setup_changed_stats()
	$_result_root_tuple.each { |k, v|
		matrix_file1 = v[0] + '/matrix.json'
		matrix_file2 = v[1] + '/matrix.json'
		next unless File.exists? matrix_file1
		next unless File.exists? matrix_file2
		if $opt_index
			matrix1 = load_json matrix_file1
			matrix2 = load_json matrix_file2
			$all_index.each { |stat, weight|
				if stat == 'time.elapsed_time'
					next unless k =~ /\/(kbuild)\//
				end
				if stat.index 'iostat.'
					next unless k =~ /\/(dd-write)\//
				end
				avg1 = get_valid_average matrix1, stat
				next unless avg1
				avg2 = get_valid_average matrix2, stat
				next unless avg2
				$changed_stats[stat][k] = v
				if $size_index[stat]
					type = 'size'
				elsif $perf_index[stat]
					type = 'perf'
				elsif $power_index[stat]
					type = 'power'
				else
					type = 'latency'
				end
				$nr_gm[type] ||= 0
				$base_gm[type] ||= 0
				$head_gm[type] ||= 0
				if weight > 0
					$nr_gm[type] += weight
					$base_gm[type] += weight * Math.log(avg1)
					$head_gm[type] += weight * Math.log(avg2)
				else
					$nr_gm[type] -= weight
					$base_gm[type] -= weight * Math.log(avg2)
					$head_gm[type] -= weight * Math.log(avg1)
				end
			}
			next
		end
		changed_stats = get_changed_stats matrix_file2, matrix_file1, $options
		next unless changed_stats and changed_stats.size > 0
		changed_stats.each { |stat, record|
			$changed_stats[stat][k] = v
			$stat_records[stat] << record
		}
	}
end

def show_one_stat(stat)
	$opt_field = stat
	_result_root_tuple = $changed_stats[stat]
	_result_root_tuple.each { |k, v|
		v.each { |_result_root| add_stats _result_root }
	}
end

def setup_dims()
	if $opt_dimension == 'commit'
		$opt_dims = ARGV.map { |v| git_commit v }
		if ARGV.size == 1
			if ARGV[0].index('/') # looks like a branch? compare its BASE_RC..HEAD
				$opt_dims.unshift git_commit(base_rc_tag($opt_dims[0]))
			elsif $opt_index
				$opt_dims.unshift git_commit(PERF_INDEX_KENREL)
			end
		end
		$longest_dims = $opt_dims
	else
		$opt_dims = ARGV
		$opt_dims.unshift PERF_INDEX_KCONFIG if ARGV.size == 1 and $opt_index
		$longest_dims = $opt_dims.sort { |a, b| b.length <=> a.length }
	end

	$opt_dims.each { |dim|
		if $dims[dim]
			puts "#{dim}(#{dim_name(dim)}) already exists in compare list"
			next
		end
		$dims[dim] = dim_name(dim)
		$first_dim ||= dim
	}
end

def show_one_diff(dim, v0, v, v_stddev, is_float, is_exp)
	if dim == $first_dim
		buf = ''
	else
		p = 100.0 * (v - v0) / v0
		if p.abs < 100000
			buf = sprintf "%+8.1f%% ", p
		else
			buf = sprintf "%+8.2g%% ", p
		end
	end

	if is_exp
		if is_float == false and v.abs < 100000000
			buf += sprintf "%#{ABS_WIDTH}d", v
		else
			buf += sprintf "%#{ABS_WIDTH}.4g", v
		end
	elsif is_float
		buf += sprintf "%#{ABS_WIDTH}.2f", v
	else
		buf += sprintf "%#{ABS_WIDTH}d", v
	end

	if v_stddev
		v_stddev = 100 * v_stddev / v if v != 0
		buf += sprintf " Â±%2d%%", v_stddev
	else
		buf += ' ' * ERR_WIDTH
	end

	printf '%s  ', buf
end

def show_test_group(key)
	printf "testbox/testcase/testparams: "
	puts key
	puts

	$dims.each { |dim, name|
		width = (dim == $first_dim ? ABS_WIDTH + ERR_WIDTH : REL_WIDTH + ABS_WIDTH + ERR_WIDTH)
		printf "%#{width}s  ", name[0..(width-1)]
	}

	puts
	$dims.keys.each { |dim|
		width = (dim == $first_dim ? ABS_WIDTH + ERR_WIDTH : REL_WIDTH + ABS_WIDTH + ERR_WIDTH)
		printf '-' * width + '  '
	}
	puts
end

def show_delta(stat, key_g)
	$cases.delete_if { |_rt, value|
		next true if value.size < 2
		next false if is_failure stat
		next false if is_latency stat
		next false if $opt_no_hide_noises
		noisy = false
		value.each { |k, v|
			next unless Array === v and v.size > 1
			if v.standard_deviation.abs > v.average.abs / 2
				noisy = true
				break
			end
		}
		noisy
	}
	return if $cases.empty?
	$cases = Hash[$cases.sort]

	if ! $group_by_test
		$dims.each { |dim, name|
			width = (dim == $first_dim ? ABS_WIDTH + ERR_WIDTH : REL_WIDTH + ABS_WIDTH + ERR_WIDTH)
			printf "%#{width}s  ", name[0..(width-1)]
		}

		if $header_shown
			puts
		else
			puts 'testbox/testcase/testparams'
		end

		$dims.keys.each { |dim|
			width = (dim == $first_dim ? ABS_WIDTH + ERR_WIDTH : REL_WIDTH + ABS_WIDTH + ERR_WIDTH)
			printf '-' * width + '  '
		}

		if $header_shown
			puts
		else
			puts '---------------------------'
			puts '     %stddev        %change               %stddev'
			puts '            \          |                 /'

			$header_shown = true
		end
	end

	is_float = false
	is_exp   = false
	$cases.each { |_rt, value|
		value.each { |k, v|
			case v
			when Array
				v.each { |vv| is_float = true if vv.abs < 100 and vv != 0 and Float === vv }
				v.each { |vv| is_exp   = true if vv.abs >= 100000000 }
			else
				is_float = true if v.abs < 100 and v != 0 and Float === v
				is_exp   = true if v.abs >= 100000000
			end
		}
	}

	$cases.each { |_rt, value|

		result_path = Result_path.new
		result_path.parse_result_root(_rt)
		test = result_path.test_desc $opt_dimension

		if $group_by_test
			next unless test == key_g
		end
		v0 = value[$first_dim]
		v0 = v0.average if Array === v0
		$dims.each { |dim, v|
			v = value[dim] || 0

			v_stddev = nil
			if Array === v
				v_stddev = v.standard_deviation if v.size > 1
				v = v.average
			end

			show_one_diff dim, v0, v, v_stddev, is_float, is_exp
			$sum[dim] += v
			if v_stddev
				$stddev[dim] += v_stddev if $stddev[dim]
			else
				$stddev[dim] = nil
			end
		}
		if $group_by_test
			puts "#{$opt_field}"
		else
			result_path['commit'] = commit_name(result_path['commit']) if $opt_dimension != 'commit'
			test = result_path.test_desc $opt_dimension
			puts test
		end
	}

	if ! $group_by_test
		v0 = $sum[$first_dim]
		$sum.each { |dim, v|
			show_one_diff dim, v0, v, $stddev[dim], is_float, is_exp
		}
		puts "TOTAL #{$opt_field}"
	end
end

def call_mmplot
	$cases.each { |_rt, value|
		file = _rt + '/matrix.json'
		matrix1 = load_json file
		matrix2 = load_json file.sub($opt_dims[0], $opt_dims[1])
		mmplot(matrix2, matrix1, [$opt_field], File.dirname(File.dirname(_rt)))
	}
end

def show_one_index(type)
	return unless $nr_gm[type]
	$base_gm[type] = Math.exp($base_gm[type] / $nr_gm[type])
	$head_gm[type] = Math.exp($head_gm[type] / $nr_gm[type])
	index = 100 * $head_gm[type] / $base_gm[type]
	printf "%6d  %8s-index  %s\n", index, type, ARGV[-1]
end

if $opt_all or $opt_index
	setup_dims
	setup_result_root_hash
	setup_changed_stats

	if $opt_index
		show_one_index 'perf'
		show_one_index 'power'
		show_one_index 'latency'
		show_one_index 'size'
		exit unless $opt_all
		puts
		stats = $changed_stats.keys
	else
		stats = sort_stats($stat_records)
	end

	if $group_by_test
		$tests.each { |key, value|
			show_test_group key
			stats.each { |stat|
				show_one_stat stat
				show_delta stat, key
				call_mmplot if $opt_plot
				$cases.clear
				$sum.clear
				$stddev.clear
			}
			puts unless $tests.empty?
		}
	else
		stats.each { |stat|
			show_one_stat stat
			show_delta stat, nil
			call_mmplot if $opt_plot
			puts unless $cases.empty?
			$cases.clear
			$sum.clear
			$stddev.clear
		}
	end
else
	ARGV.each { |path| add_stats path }
	show_delta $opt_field, nil
	plot_bar $dims, $cases if $opt_plot
end
